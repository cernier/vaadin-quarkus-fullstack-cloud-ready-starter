# Vaadin-Quarkus full-stack and cloud-native starter

The **full-stack** starter-as-a-tutorial of [**Vaadin**](https://vaadin.com/) application, ready for containerized
and **cloud-native** deployment as powered by [**Quarkus**](https://quarkus.io/).

<img width="610" alt="app" src="https://user-images.githubusercontent.com/1899972/179356876-3d1b59ca-1b30-4ab7-ade7-ba180b01340d.png">

Enabling logs monitoring or DB admin (PostgreSQL) directly in the cloud:

<p float="left">
<img width="300" alt="okteto-logs" src="https://user-images.githubusercontent.com/1899972/179357048-ae6994b3-323d-4d44-b69e-347125be9fc7.png">
&nbsp;
<img width="300" alt="db-admin" src="https://user-images.githubusercontent.com/1899972/179357075-b5e63960-85f0-4cbc-91cd-37f79337b4d2.png">
</p>

(following
previous [« Vaadin + Spring-Boot + GORM + Groovy + Maven »](https://github.com/cernier/vaadin-springboot-gorm-groovy-maven-sample)
sample-as-a-tutorial last year)

# TL;DR

* Just
  click [![Deploy on Okteto](https://okteto.com/develop-okteto.svg)](https://cloud.okteto.com/deploy?repository=https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter)
  to deploy this ready-to-use multi-node application to the [**Okteto cloud
  infrastructure**](https://www.okteto.com/docs/welcome/overview/) (logged from your `github-username` GitHub account)
    * and access it directly at <ins>https:// www-vaadin-quarkus-`github-username`.cloud.okteto.net</ins>, which for
      this GitHub account is accessible at:\
      [`https://www-vaadin-quarkus-cernier.cloud.okteto.net`](https://www-vaadin-quarkus-cernier.cloud.okteto.net)

* or, locally, just launch `./mvnw` to build and run one node of this starter application (from a Java 11+ environment).
    * and access it directly at [`http://localhost:8080`](http://localhost:8080)

# Content

* As a **Quarkus** starter app, it includes:
    * several Quarkus capacities: persistence (over PostgreSQL here), transaction, caching, OIDC authentication, etc…
      among all the (very numerous) others that Quarkus enables through [its guides](https://quarkus.io/guides).
    * its very developer-friendly **live code reloading feature**, when running locally in [_"Development
      mode"_](https://quarkus.io/guides/maven-tooling#dev-mode)
* As a **Vaadin** starter app, its UI can be extended up to all what Vaadin enables, calling the underlying
  Quarkus-powered services.
* As a **cloud-native** starter app, it enables straightforward deployment on
  any [`docker-compose`](https://docs.docker.com/compose/)-based infrastructure (like AWS, GCP, Azure, but here in our
  case [Okteto](https://www.okteto.com/docs/tutorials/compose-getting-started/) as a free alternative).

## How-to use

In terms of structure, this repository can be used as a…

### <ins>Ready-to-use starter</ins>

"as is", i.e. a starting base on top of which anyone can directly build and extend its own app.

Just [**fork it**](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/fork) to do so!

### <ins>Tutorial</ins>

It's also possible to follow those instructions detailing the incremental steps per framework piece to build this
starter app.

#### 0. After forking [`vaadin/base-starter-flow-quarkus`](https://github.com/vaadin/base-starter-flow-quarkus) and few cleanup…

#### 1. Initialize the core of the starter app (commit [[`9756f36`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/commit/9756f36)])

[<img src="https://design.jboss.org/quarkus/logo/final/PNG/quarkus_logo_vertical_rgb_1280px_reverse_blackbkg.png" width="150px" />](https://quarkus.io/)

<details>
<summary>Instructions (involving Quarkus' persistence through Panache, transaction, caching, dependency injection)</summary>
<br/>

Inspiring from skeleton generated by [`start.vaadin.com`](https://start.vaadin.com)…

* (1.1) With the same 2
  views: [`HelloWorldView`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/9756f36/src/main/java/com/example/starter/base/views/helloworld/HelloWorldView.java)
  and [`AboutView`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/9756f36/src/main/java/com/example/starter/base/views/about/AboutView.java)
  , both being fully `@AnonymousAllowed` i.e. accessible to anonymous user.\
  But, instead of relying on Spring Boot, adapted to Quarkus, including:


* (1.2) With persistence handled by [Panache](https://quarkus.io/guides/hibernate-orm-panache), the Quarkus adaptation
  of Hibernate ORM.

  So far, persistence is just based on an [in-memory H2 database](https://www.h2database.com/html/main.html), as visible
  in,<br/>
  project's [`pom.xml`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/9756f36/pom.xml):

  ```xml
  <project>
      ...
      <dependency>
          <groupId>io.quarkus</groupId>
          <artifactId>quarkus-hibernate-orm-panache</artifactId>
      </dependency>
      <dependency>
          <groupId>io.quarkus</groupId>
          <artifactId>quarkus-jdbc-h2</artifactId>
      </dependency>
      ...
  </project>
  ```

  and in
  default [`application.properties`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/9756f36/src/main/resources/application.properties)
  configuration:

  ```properties
  #
  quarkus.datasource.db-kind=h2
  quarkus.datasource.jdbc.url=jdbc:h2:mem:vaadin-quarkus-fullstack-cloud-ready-starter
  #
  # quarkus.hibernate-orm.database.generation=drop-and-create
  quarkus.hibernate-orm.database.generation=update
  #
  ```

  (so far, `drop-and-create` generation can be kept in a single node context, but `update` one is required in a
  clustered
  multi-node context so that each node startup does not destroy the existing database)

  With in
  the [`User`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/9756f36/src/main/java/com/example/starter/base/model/User.java)
  entity, those persistence utilities for reading (`findBy...`) or
  writing (`saveOrUpdateWith...`) directly relying on Panache utilities (or intermediate ones defined
  in [`AbstractEntity`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/9756f36/src/main/java/com/example/starter/base/model/AbstractEntity.java))
  .

  ```java
  @Getter
  @Setter
  @Builder
  @AllArgsConstructor
  @NoArgsConstructor
  @ToString
  @Entity
  public class User extends AbstractEntity {
  
    @NotEmpty
    @Column(unique = true)
    private String username;
  
    // persistence utilities
  
    public static Optional<User> findByUsernameOptional(String username) {
      return find("username", username).singleResultOptional();
    }
  
    public static User saveOrUpdateWithUniqueUsername(User user) {
      return saveOrUpdateWithIdOfExisting(user,
          findByUsernameOptional(user.username).map(User::getId));
    }
  
    // ...
  }
  ```

  And whose methods are then accessible from Quarkus business services, like the `@ApplicationScoped`-annotated
  one `UserService`:

  (note the usages of [Quarkus-transaction](https://quarkus.io/guides/transaction)
  or [Quarkus-cache](https://quarkus.io/guides/cache) mechanisms)

  ```java
  @ApplicationScoped
  public class UserService {
  
    private static final String CACHE_NAME = "user";
  
    @Inject
    @CacheName(CACHE_NAME)
    Cache cache;
  
    @CacheResult(cacheName = UserService.CACHE_NAME)
    public Optional<User> findByUsernameOptional(@CacheKey String username) {
      return User.findByUsernameOptional(username);
    }
  
    @Transactional
    public User saveOrUpdateWithUniqueUsername(User user) {
      return cache.invalidate(user.getUsername())
          .chain(() -> Uni.createFrom().item(User.saveOrUpdateWithUniqueUsername(user)))
          .await().indefinitely();
    }
  }
  ```

* (1.3) With a
  simple [`SecurityService`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/9756f36/src/main/java/com/example/starter/base/services/SecurityService.java)
  that just fakes authentication of a `"default"` user persisted through the previously mentioned `UserService`.

* (1.4) The several `*Service` classes (the 2 previous ones and any future functional service) can then be aggregated
  and accessible through a single
  entry-point [`Services`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/9756f36/src/main/java/com/example/starter/base/services/Services.java) (
  e.g. `Services.get().getUserService()` or `Services.get().getSecurityService()`).

  This `Services` entry-point class being bound to Vaadin session, it can be used wherever in the UI layer, thanks to
  this registering in the `@UIScoped`-annotated main view.

  ```java
  @UIScoped
  // ...
  public class HelloWorldView extends HorizontalLayout {
  
    // ...
  
    @Inject
    Services services;
  
    @PostConstruct
    public void init() {
      services.registerIn(VaadinSession.getCurrent());
      initializeViewContent();
    }
  
    public HelloWorldView() {
    }
  
    private void initializeViewContent() {
      // ...
    }
  }
  ```

* (1.5) Then, for
  example, [`MainLayout`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/9756f36/src/main/java/com/example/starter/base/views/MainLayout.java)
  can makes use of `Services.get().getSecurityService()` to customize user menu.

  ```java
  public class MainLayout extends AppLayout implements RouterLayout {
  
    // ...
  
    private Footer createFooter() {
      // ...
      Services.get().getSecurityService().getLoggedUser().ifPresentOrElse(user -> {
            String userDisplayName = String.format("%s %s", user.getFirstName(), user.getLastName());
            Avatar avatar = new Avatar(userDisplayName, user.getPictureURL());
  
            userMenu.addItem("Profile");
            userMenu.addItem("Logout", e -> getUI().ifPresent(ui -> ui.getPage().setLocation("/logout")));
  
            Span name = new Span(userDisplayName);
  
            // ...
  
            layout.add(avatar, name);
          },
          () -> {
            Avatar avatar = new Avatar();
  
            userMenu.addItem("Sign in", e -> getUI().ifPresent(ui -> ui.getPage().setLocation("/login")));
  
            Span signIn = new Span("Not signed");
  
            // ...
  
            layout.add(avatar, signIn);
          });
    }
  }
  ```

</details>

#### 2. Add OpenID authentication provided by [Auth0](https://auth0.com/) (commit [[`8679e4e`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/commit/8679e4e)])

[<img src="https://openid.net/wordpress-content/uploads/2011/09/OPENID_CONNECT_NEW-Logo-1024x474.jpg" width="150px" />](https://openid.net/)

[<img src="https://cdn.geekwire.com/wp-content/uploads/2015/06/Auth0-300x122.png" width="150px" />](https://auth0.com/)

<details>
<summary>Instructions</summary>
<br/>

As adaptation
of [the dedicated OIDC with Quarkus guide](https://quarkus.io/guides/security-openid-connect-web-authentication), it
just requires:

* introducing this simple dependency in
  project's [`pom.xml`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/8679e4e/pom.xml):

  ```xml
  <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-oidc</artifactId>
  </dependency>
  ```

* and, provided [Auth0's tenant and application](https://auth0.com/docs/quickstart/webapp/java/interactive) is
  correctly configured, filling below `auth-server-url`, `client-id`, `credentials.secret`, `authentication.scopes`
  values
  in [`application.properties`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/8679e4e/src/main/resources/application.properties)

  ```properties
  quarkus.http.auth.permission.authenticated.paths=/login
  quarkus.http.auth.permission.authenticated.policy=authenticated
  #
  quarkus.oidc.auth-server-url=https://vaadin-quarkus-fullstack-cloud-ready-starter.eu.auth0.com
  quarkus.oidc.application-type=web_app
  quarkus.oidc.client-id=pTgnuUseJm8IQjG0KuzVYLob1nVbZSDL
  quarkus.oidc.credentials.secret=99Ne1cW4G08urS4FYzBE3YDxjUtfyxHDtMhYNF7OyHsofPSOunqB0Rs4h9XjM-FF
  quarkus.oidc.authentication.scopes=openid,profile,email
  quarkus.oidc.authentication.redirect-path=/post-login
  ```

Note the presence here of client id and corresponding credentials' secret, both in clear, which is not an issue just for
this Auth0 app created for this tutorial/starter.
\
But in a real case, this should rather be externalized, like through
a [Github secret](https://docs.github.com/en/actions/security-guides/encrypted-secrets#creating-encrypted-secrets-for-a-repository)
.

* so that the fake authentication logic
  in [`SecurityService`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/8679e4e/src/main/java/com/example/starter/base/services/SecurityService.java)
  can be then replaced by an actual one relying on values coming from OIDC provider through injected token and session,
  in order to
  fill [newly introduced fields in `User` entity](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/8679e4e/src/main/java/com/example/starter/base/model/User.java):

  ```java
  @ApplicationScoped
  public class SecurityService {
  
    @Inject
    @IdToken
    JsonWebToken idToken;
  
    @Inject
    OidcSession oidcSession;
  
    // ...
  
    public Optional<User> getLoggedUser() {
      // ...
      String username = idToken.getSubject();
      // ...
      LocalDateTime issuedTokenDateTime = LocalDateTime.ofEpochSecond(idToken.getIssuedAtTime(), 0, ZoneOffset.UTC);
      // ...
      result.setLastUpdatedAt(issuedTokenDateTime);
      result.setFirstName(idToken.getClaim("given_name"));
      result.setLastName(idToken.getClaim("family_name"));
      result.setEmail(idToken.getClaim("email"));
      result.setPictureURL(idToken.getClaim("picture"));
      // ...
    }
  
    public void logout() {
      oidcSession.logout().await().indefinitely();
    }
  
    private boolean noUserIsLogged() {
      return oidcSession.getIdToken() == null;
    }
  
  }
  ```

</details>

#### 3. Add role management (commit [[`860f118`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/commit/860f118)])

Based on the just previously introduced OpenID-based authentication.

<details>
<summary>Instructions (introducing "role" mechanism to give or not access to some users to some views of the app)</summary>
<br/>

* Introduce `enum`
  type [`Role`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/860f118/src/main/java/com/example/starter/base/model/Role.java)
  representing the different roles supported by the app (here just 2 basic ones, but it can obviously be extended up to
  what the app needs)

  ```java
  public enum Role {
    USER,
    ADMIN
  }
  ```

* Make
  [`User`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/860f118/src/main/java/com/example/starter/base/model/User.java)
  possibly having several roles

  ```java
  
  @Entity
  public class User extends AbstractEntity {
  
    // ...
  
    @ElementCollection
    @CollectionTable
    @Enumerated(EnumType.STRING)
    private List<Role> roles;
  
    // ...
  
  }
  ```

* All the logic that "augments" any logged user, with its roles stored in the persistence layer, resides in
  the [Quarkus' security customization](https://quarkus.io/guides/security-customization#security-identity-customization)
  enabled by what is called a `SecurityIdentityAugmentor`.
  \
  And whose our
  implementation [`RolesAugmentorFromUserInPersistence`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/860f118/src/main/java/com/example/starter/base/services/security/RolesAugmentorFromUserInPersistence.java)
  looks like:

  ```java
  @ApplicationScoped
  public class RolesAugmentorFromUserInPersistence implements SecurityIdentityAugmentor {
  
    @Inject
    Instance<SecurityIdentityEnhancerWithUserRoles> enhancerWithUserRolesProvider;
  
    @Override
    public Uni<SecurityIdentity> augment(SecurityIdentity identity, AuthenticationRequestContext context) {
      SecurityIdentityEnhancerWithUserRoles enhancerWithUserRoles = enhancerWithUserRolesProvider.get();
      enhancerWithUserRoles.setSecurityIdentity(identity);
      return context.runBlocking(enhancerWithUserRoles);
    }
  
    @Dependent
    private static class SecurityIdentityEnhancerWithUserRoles implements Supplier<SecurityIdentity> {
  
      @Inject
      UserService userService;
  
      @Setter
      private SecurityIdentity securityIdentity;
  
      @ActivateRequestContext
      @Override
      public SecurityIdentity get() {
        if (securityIdentity.isAnonymous()) {
          return securityIdentity;
        } else {
          // create a new builder and copy principal, attributes, credentials and roles from the original identity
          QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder(securityIdentity);
  
          // add custom role source here
          builder.addRoles(userService.findByUsernameOptional(securityIdentity.getPrincipal().getName())
              .map(User::getRoles).stream().flatMap(Collection::stream)
              .map(Role::name).collect(Collectors.toSet()));
  
          return builder.build();
        }
      }
    }
  }
  ```

* Let's make the on-the-fly user registration
  in [`SecurityService`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/860f118/src/main/java/com/example/starter/base/services/security/SecurityService.java)
  to consider `USER` as the default role:
  ```java
  @ApplicationScoped
  public class SecurityService {
  
    @Transactional
    public Optional<User> getLoggedUser() {
  
      // ...
  
      User result = userService.findByUsernameOptional(username)
          .orElseGet(() -> User.builder()
              .username(username)
              .roles(List.of(Role.USER)) // default user role
              .build());
      
      // ...

    }
  }
  ```


* Once roles are thus correctly bound to the security layer, Vaadin views can very easily restrict access to some of
  those roles.

  Like
  in [`AboutView`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/860f118/src/main/java/com/example/starter/base/views/about/AboutView.java):

  ```java
  @RolesAllowed("USER")
  public class AboutView extends VerticalLayout {
    // ...
  }
  ```

</details>

#### 4. Docker-ization (commit [[`64fbbf1`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/commit/64fbbf1)])

[<img src="https://www.docker.com/wp-content/uploads/2022/03/horizontal-logo-monochromatic-white.png.webp" width="150px" />](https://docker.com/)

Build of [Docker image](https://docs.docker.com/get-started/overview/#docker-architecture) and its execution in
a `docker-compose`-based environment.

* Thanks to
  dedicated [`Dockerfile`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/64fbbf1/Dockerfile)
  to build Quarkus application.
    * which at the same time performs
      the [Vaadin build with production profile](https://vaadin.com/docs/latest/production/production-build)
      (`-Pproduction` in the Maven build command line)

* And this very
  minimalist [`docker-compose.yml`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/64fbbf1/docker-compose.yml)
  descriptor to basically deploy single-node :
  ```yaml
  services:
    app:
      build: .
      ports:
        - 8080:8080
      restart: always
  ```

#### 5. GitHub action to trigger deployment to Okteto (commit [[`be12b03`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/commit/be12b03)])

[<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" width="100px" />](https://github.com/features/actions)

[<img src="https://www.okteto.com/okteto-meta-image.png" width="150px" />](https://github.com/marketplace?type=actions&query=okteto)

[`.github/workflows/deploy-to-okteto.yml`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/be12b03/.github/workflows/deploy-to-okteto.yml)
,
that specifies what's to be done on each commit pushed on `master` branch, has just to be very minimal:

```yaml
name: Deploy to Okteto

on:
  push:
    branches:
      - master

jobs:
  deploy-to-okteto:
    name: Deploy to Okteto
    runs-on: ubuntu-latest

    steps:

      - uses: actions/checkout@v3

      - uses: okteto/login@latest
        with:
          token: ${{ secrets.OKTETO_TOKEN }}

      - uses: okteto/create-namespace@latest
        with:
          namespace: vaadin-quarkus-${{ github.actor }}

      - uses: okteto/deploy-stack@latest
        with:
          build: "true"
```

* Obviously, it requires the API
  token `OKTETO_TOKEN` [saved as secret in your GitHub repository](https://docs.github.com/en/actions/security-guides/encrypted-secrets)
  , with value
  from [a correctly configured Okteto account](https://github.com/okteto/login#configure-your-okteto-api-token)
* As image build is directly specified within `Dockerfile`, it's not occurring on GitHub but directly on Okteto just
  before deploying the built image.\
  Hence the `build : "true"` parameter
  using [`okteto/deploy-stack` GitHub action](https://github.com/okteto/deploy-stack).
* Usage of `${{ github.actor }}` just refers to GitHub username, to ensure that URLs generated by Okteto (from
  namespace) are specific to such username, and thus avoid any collision.

#### 6. Add PostgreSQL DB (and pgAdmin in Docker-ized env) (commit [[`437b7c0`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/commit/437b7c0)])

As underlying data layer still relies on in-memory H2 database attached to the single `app` node, in order **to be able
to scale** to several app nodes with consistency between them, it requires to move to a **single datasource**.

[<img src="https://wiki.postgresql.org/images/3/30/PostgreSQL_logo.3colors.120x120.png" width="100px" />](https://www.postgresql.org)

It's done here by moving to a single [**PostgreSQL**](https://www.postgresql.org) instance used by those coming soon
several app nodes:
in [Maven POM](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/437b7c0/pom.xml)
, [`docker-compose.yml`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/437b7c0/docker-compose.yml)
(introducing new `db` and `db-admin` services respectively based on [`postgres`](https://hub.docker.com/_/postgres)
and [`pgAdmin`](https://hub.docker.com/r/dpage/pgadmin4) Docker images) and
configuration ([default](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/437b7c0/src/main/resources/application.properties)
and [`production` one](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/437b7c0/src/main/resources/application-production.properties)).\
Obviously and as visible in the corresponding default configuration, running locally requires a PostgresQL DB instance accessible at `localhost:5432`.

#### 7. Scale to 4-node cluster behind nginx reverse-proxy (commit [[`c21aae6`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/commit/c21aae6)])

[<img src="https://www.nginx.com/wp-content/uploads/2020/07/nginx-default_featured-2020.png" width="150px" />](https://www.nginx.com/)

Last step of this tutorial, but not least one as it consists on the easy capacity to scale containerized nodes in the
cloud.
Which is made very simple by the cloud-native nature of Quarkus and the Docker-ization previously described.

Ideally, to scale for example to 4 nodes, we should just have to define accordingly the `deploy.replicas` properties in
the `app` service defined in `docker-compose.yml`, like this:

```yaml
services:
  app:
    ...
    deploy:
      replicas: 4
```

But for a reason detailed below, it's in our case not possible.\
Therefore, an easy way to do it, even if not dynamic so far, is to just repeat references to the 1st node, using
the `&app` anchor's and `<<: *app`
aliases' [YAML syntax](https://medium.com/@kinghuang/docker-compose-anchors-aliases-extensions-a1e4105d70bd#a044):

```yaml
services:

  ...

  app1: &app
    build: .
    ports:
      - 8080
    restart: always
    depends_on:
      - db
  app2:
    <<: *app
    depends_on:
      - app1
      - db
  app3:
    <<: *app
    depends_on:
      - app2
      - db
  app4:
    <<: *app
    depends_on:
      - app3
      - db
```

Note that, unlike the previous `8080:8080` syntax which exposed the internal `8080` port of the `app` node, externally
to the port with same number, all `app*` nodes won't be anymore exposed through such a port.

Instead, only the single input port (`80`) of [`nginx`](https://hub.docker.com/_/nginx)-based service called `www` is
exposed to the outside of the stack:

```yaml
services:
  www:
    image: nginx
    ports:
      - 80:80
    restart: always
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - app1
      - app2
      - app3
      - app4
```

Such [`nginx`](https://www.nginx.com/) **reverse proxy** needs
a [`nginx.conf`](https://github.com/cernier/vaadin-quarkus-fullstack-cloud-ready-starter/blob/c21aae6/nginx.conf) here
accessible at the root `./` folder of the project/repository, and mapped to `/etc/nginx/` folder when containerized.

The most interesting is obviously the `http` part, mapping the `app` layer to the web `server` one exposed by the
stack:

```
...

http {
  upstream app {
    hash $remote_addr consistent;

    server app1:8080;
    server app2:8080;
    server app3:8080;
    server app4:8080;
  }
  server {
    listen 80;
    location / {
      proxy_pass http://app;

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-Host $host:$server_port;
      proxy_set_header X-Forwarded-Server $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
  }
}
```

Note in particular:

* the usage
  of [`hash $remote_addr consistent;` directive](http://nginx.org/en/docs/stream/ngx_stream_upstream_module.html#hash),
  which specifies a load-balancing method based on an hashed value of the client's IP address.\
  This ensures a kind of **sticky session** behaviour (and even more), enabling that all requests related to a given
  session (and even to a given client IP, in this case) goes to a same node behind the reverse proxy ; which is a
  constraint [required by usage of Vaadin and more specifically related to `VaadinSession`](https://vaadin.com/docs/latest/advanced/application-lifecycle/#application.lifecycle.session)
  , cf. [`vaadin/base-starter-flow-quarkus`' issue #19](https://github.com/vaadin/base-starter-flow-quarkus/issues/19)).
* as said above, it appears not being possible to use a single service `app` scalable directly
  thanks to `deploy.replicas: 4` property (which usually enables distinct nodes' internal hostnames to be dynamically
  managed by `docker-compose`).
  Because this solution is not compatible with the `nginx` load-balancing hash-based method described above (or at
  least its usage within Okteta infrastructure) which requires statically defined hostnames like `app1`, `app2`, `app3`,
  etc.
